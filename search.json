[
  {
    "objectID": "main.html#inferopt.jl",
    "href": "main.html#inferopt.jl",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "InferOpt.jl",
    "text": "InferOpt.jl\n\nState-of-the-art tools to incorporate combinatorial optimization algorithms in machine learning pipelines\nCompatible with ML and AD ChainRules Julia ecosystem\nPart of the new JuliaDecisionFocusedLearning GitHub organization"
  },
  {
    "objectID": "main.html#why",
    "href": "main.html#why",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Why?",
    "text": "Why?\n\nIncrease the expressivity of machine learning models, by having combinatorial outputs\nLeverage algorithms for “easy” problems to solve harder ones\n\nDifficulty: combinatorial algorithms are piecewise constant functions \\(\\implies\\) no informative gradients\n\nInferOpt provides differentiable layers and loss functions to overcome this issue."
  },
  {
    "objectID": "main.html#path-finding-on-warcraft-maps",
    "href": "main.html#path-finding-on-warcraft-maps",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Path finding on Warcraft maps",
    "text": "Path finding on Warcraft maps\n\nInput: map image\nGoal: find the shortest path from top left to bottom right\nTrue cell costs are unknown\n\n\n\n\n\n\nDataset: Set of (image, path) pairs to imitate"
  },
  {
    "objectID": "main.html#retrieving-the-dataset",
    "href": "main.html#retrieving-the-dataset",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Retrieving the dataset",
    "text": "Retrieving the dataset\n\nusing InferOptBenchmarks.Warcraft\nb = WarcraftBenchmark();\n\nDownload and format the data:\n\ndataset = generate_dataset(b, 50)\ntrain_dataset, test_dataset = dataset[1:45], dataset[46:50]\nx, y_true, θ_true = test_dataset[1]\nplot_data(x, y_true, θ_true)"
  },
  {
    "objectID": "main.html#the-neural-network",
    "href": "main.html#the-neural-network",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "The neural network",
    "text": "The neural network\n\n\nFirst three layers of a resnet\n\nmodel = generate_statistical_model(b)\n\nChain(\n  Conv((7, 7), 3 =&gt; 64, pad=3, stride=2, bias=false),  # 9_408 parameters\n  BatchNorm(64, relu),                  # 128 parameters, plus 128\n  MaxPool((3, 3), pad=1, stride=2),\n  Parallel(\n    addact(NNlib.relu, ...),\n    identity,\n    Chain(\n      Conv((3, 3), 64 =&gt; 64, pad=1, bias=false),  # 36_864 parameters\n      BatchNorm(64),                    # 128 parameters, plus 128\n      NNlib.relu,\n      Conv((3, 3), 64 =&gt; 64, pad=1, bias=false),  # 36_864 parameters\n      BatchNorm(64),                    # 128 parameters, plus 128\n    ),\n  ),\n  AdaptiveMaxPool((12, 12)),\n  InferOptBenchmarks.Warcraft.average_tensor,\n  InferOptBenchmarks.Warcraft.neg_tensor,\n  InferOptBenchmarks.Warcraft.squeeze_last_dims,\n)         # Total: 9 trainable arrays, 83_520 parameters,\n          # plus 6 non-trainable, 384 parameters, summarysize 330.312 KiB.\n\n\n\nPredicted costs\n\nusing Plots\nθ = model(x)\n\nkw = (; framestyle=:none, yflip=true, aspect_ratio=:equal, legend=false, size=(300, 300))\nclim=(minimum(θ_true), maximum(θ_true))\nheatmap(-θ; kw..., clim)"
  },
  {
    "objectID": "main.html#combinatorial-algorithm",
    "href": "main.html#combinatorial-algorithm",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Combinatorial algorithm",
    "text": "Combinatorial algorithm\nWe use the Dijkstra algorithm, wrapped from Graphs.jl\n\nmaximizer = generate_maximizer(b)\n\ndijkstra_maximizer (generic function with 1 method)\n\n\n\n\nOutput of untrained pipeline\n\nheatmap(maximizer(θ); kw...)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nPath we want to output\n\nheatmap(maximizer(-θ_true); kw...)"
  },
  {
    "objectID": "main.html#computing-derivatives-zygote",
    "href": "main.html#computing-derivatives-zygote",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Computing derivatives (Zygote)",
    "text": "Computing derivatives (Zygote)\nEither fails…\n\nusing Zygote\n\nZygote.jacobian(maximizer, θ)\n\nErrorException: ErrorException(\"Mutating arrays is not supported -- called setindex!(Matrix{Int64}, ...)\\nThis error occurs when you ask Zygote to differentiate operations that change\\nthe elements of arrays in place (e.g. setting values with x .= ...)\\n\\nPossible fixes:\\n- avoid mutating operations (preferred)\\n- or read the documentation and solutions for this error\\n  https://fluxml.ai/Zygote.jl/latest/limitations\\n\")\nMutating arrays is not supported -- called setindex!(Matrix{Int64}, ...)\nThis error occurs when you ask Zygote to differentiate operations that change\nthe elements of arrays in place (e.g. setting values with x .= ...)\n\nPossible fixes:\n- avoid mutating operations (preferred)\n- or read the documentation and solutions for this error\n  https://fluxml.ai/Zygote.jl/latest/limitations\n\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n  [2] _throw_mutation_error(f::Function, args::Matrix{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/array.jl:70\n  [3] (::Zygote.var\"#539#540\"{Matrix{Int64}})(::Nothing)\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/array.jl:82\n  [4] (::Zygote.var\"#2623#back#541\"{Zygote.var\"#539#540\"{Matrix{Int64}}})(Δ::Nothing)\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [5] path_to_matrix\n    @ ~/.julia/packages/InferOptBenchmarks/zB6U9/src/Warcraft/grid_graph.jl:121 [inlined]\n  [6] (::Zygote.Pullback{Tuple{typeof(InferOptBenchmarks.Warcraft.path_to_matrix), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Vector{Int64}}, Any})(Δ::Matrix{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n  [7] #dijkstra_maximizer#12\n    @ ~/.julia/packages/InferOptBenchmarks/zB6U9/src/Warcraft/grid_graph.jl:289 [inlined]\n  [8] (::Zygote.Pullback{Tuple{InferOptBenchmarks.Warcraft.var\"##dijkstra_maximizer#12\", @Kwargs{}, typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer), Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Int64}, Tuple{Zygote.Pullback{Tuple{typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Int64, LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Tuple{Zygote.Pullback{Tuple{Graphs.var\"##dijkstra_shortest_paths#142\", Bool, Bool, Float32, typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Int64, LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{Type{NamedTuple{(:allpaths, :trackvertices, :maxdist)}}, Tuple{Bool, Bool, Float32}}, Tuple{Zygote.var\"#2220#back#315\"{Zygote.Jnew{@NamedTuple{allpaths::Bool, trackvertices::Bool, maxdist::Float32}, Nothing, true}}}}, Zygote.ZBack{ChainRules.var\"#vcat_pullback#481\"{Tuple{ChainRulesCore.ProjectTo{Float64, @NamedTuple{}}}, Tuple{Tuple{}}, Val{1}}}, Zygote.Pullback{Tuple{typeof(Core.kwcall), @NamedTuple{allpaths::Bool, trackvertices::Bool, maxdist::Float32}, typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Vector{Int64}, LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Any}}}, Zygote.Pullback{Tuple{typeof(eltype), LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}, Zygote.Pullback{Tuple{typeof(Graphs.weights), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}}, Tuple{Zygote.ZBack{ChainRules.var\"#adjoint_mat_pullback#1127\"{ChainRulesCore.ProjectTo{SparseArrays.SparseMatrixCSC, @NamedTuple{element::ChainRulesCore.ProjectTo{Float32, @NamedTuple{}}, axes::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, rowval::Vector{Int64}, nzranges::Vector{UnitRange{Int64}}, colptr::Vector{Int64}}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:weights, Zygote.Context{false}, SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, SparseArrays.SparseMatrixCSC{Float32, Int64}}}}}}}, Zygote.Pullback{Tuple{typeof(InferOptBenchmarks.Warcraft.path_to_matrix), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Vector{Int64}}, Any}, Zygote.var\"#3615#back#1100\"{Zygote.var\"#1096#1099\"}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:parents, Zygote.Context{false}, Graphs.DijkstraState{Float32, Int64}, Vector{Int64}}}, Zygote.Pullback{Tuple{typeof(Graphs.nv), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.Pullback{Tuple{typeof(Graphs.weights), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}}, Tuple{Zygote.ZBack{ChainRules.var\"#adjoint_mat_pullback#1127\"{ChainRulesCore.ProjectTo{SparseArrays.SparseMatrixCSC, @NamedTuple{element::ChainRulesCore.ProjectTo{Float32, @NamedTuple{}}, axes::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, rowval::Vector{Int64}, nzranges::Vector{UnitRange{Int64}}, colptr::Vector{Int64}}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:weights, Zygote.Context{false}, SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, SparseArrays.SparseMatrixCSC{Float32, Int64}}}}}, Zygote.ZBack{Zygote.var\"#IntX_pullback#335\"}}}, Zygote.Pullback{Tuple{typeof(InferOptBenchmarks.Warcraft.get_path), Vector{Int64}, Int64, Int64}, Any}, Zygote.Pullback{Tuple{typeof(warcraft_grid_graph), Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{InferOptBenchmarks.Warcraft.var\"##warcraft_grid_graph#1\", Bool, typeof(warcraft_grid_graph), Matrix{Float32}}, Any}}}}})(Δ::Matrix{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n  [9] dijkstra_maximizer\n    @ ~/.julia/packages/InferOptBenchmarks/zB6U9/src/Warcraft/grid_graph.jl:285 [inlined]\n [10] #291\n    @ ~/.julia/packages/Zygote/nsBv0/src/lib/lib.jl:206 [inlined]\n [11] (::Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer), Matrix{Float32}}, Tuple{Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.Pullback{Tuple{InferOptBenchmarks.Warcraft.var\"##dijkstra_maximizer#12\", @Kwargs{}, typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer), Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Int64}, Tuple{Zygote.Pullback{Tuple{typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Int64, LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Tuple{Zygote.Pullback{Tuple{Graphs.var\"##dijkstra_shortest_paths#142\", Bool, Bool, Float32, typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Int64, LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{Type{NamedTuple{(:allpaths, :trackvertices, :maxdist)}}, Tuple{Bool, Bool, Float32}}, Tuple{Zygote.var\"#2220#back#315\"{Zygote.Jnew{@NamedTuple{allpaths::Bool, trackvertices::Bool, maxdist::Float32}, Nothing, true}}}}, Zygote.ZBack{ChainRules.var\"#vcat_pullback#481\"{Tuple{ChainRulesCore.ProjectTo{Float64, @NamedTuple{}}}, Tuple{Tuple{}}, Val{1}}}, Zygote.Pullback{Tuple{typeof(Core.kwcall), @NamedTuple{allpaths::Bool, trackvertices::Bool, maxdist::Float32}, typeof(Graphs.dijkstra_shortest_paths), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Vector{Int64}, LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Any}}}, Zygote.Pullback{Tuple{typeof(eltype), LinearAlgebra.Adjoint{Float32, SparseArrays.SparseMatrixCSC{Float32, Int64}}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}, Zygote.Pullback{Tuple{typeof(Graphs.weights), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}}, Tuple{Zygote.ZBack{ChainRules.var\"#adjoint_mat_pullback#1127\"{ChainRulesCore.ProjectTo{SparseArrays.SparseMatrixCSC, @NamedTuple{element::ChainRulesCore.ProjectTo{Float32, @NamedTuple{}}, axes::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, rowval::Vector{Int64}, nzranges::Vector{UnitRange{Int64}}, colptr::Vector{Int64}}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:weights, Zygote.Context{false}, SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, SparseArrays.SparseMatrixCSC{Float32, Int64}}}}}}}, Zygote.Pullback{Tuple{typeof(InferOptBenchmarks.Warcraft.path_to_matrix), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, Vector{Int64}}, Any}, Zygote.var\"#3615#back#1100\"{Zygote.var\"#1096#1099\"}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:parents, Zygote.Context{false}, Graphs.DijkstraState{Float32, Int64}, Vector{Int64}}}, Zygote.Pullback{Tuple{typeof(Graphs.nv), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.Pullback{Tuple{typeof(Graphs.weights), SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}}, Tuple{Zygote.ZBack{ChainRules.var\"#adjoint_mat_pullback#1127\"{ChainRulesCore.ProjectTo{SparseArrays.SparseMatrixCSC, @NamedTuple{element::ChainRulesCore.ProjectTo{Float32, @NamedTuple{}}, axes::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, rowval::Vector{Int64}, nzranges::Vector{UnitRange{Int64}}, colptr::Vector{Int64}}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:weights, Zygote.Context{false}, SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64, Float32}, SparseArrays.SparseMatrixCSC{Float32, Int64}}}}}, Zygote.ZBack{Zygote.var\"#IntX_pullback#335\"}}}, Zygote.Pullback{Tuple{typeof(InferOptBenchmarks.Warcraft.get_path), Vector{Int64}, Int64, Int64}, Any}, Zygote.Pullback{Tuple{typeof(warcraft_grid_graph), Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{InferOptBenchmarks.Warcraft.var\"##warcraft_grid_graph#1\", Bool, typeof(warcraft_grid_graph), Matrix{Float32}}, Any}}}}}}}}})(Δ::Matrix{Int64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n [12] call_composed\n    @ ./operators.jl:1045 [inlined]\n [13] (::Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Any})(Δ::Matrix{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [14] call_composed\n    @ ./operators.jl:1044 [inlined]\n [15] #_#103\n    @ ./operators.jl:1041 [inlined]\n [16] (::Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, typeof(Zygote._jvec)}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Matrix{Int64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Matrix{Int64}}, Tuple{Zygote.var\"#2763#back#609\"{Zygote.var\"#603#607\"{Matrix{Int64}, Tuple{Int64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}}}, Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}}}}})(Δ::Vector{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [17] #291\n    @ ~/.julia/packages/Zygote/nsBv0/src/lib/lib.jl:206 [inlined]\n [18] #2169#back\n    @ ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72 [inlined]\n [19] ComposedFunction\n    @ ./operators.jl:1041 [inlined]\n [20] (::Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Matrix{Float32}}, Tuple{Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, typeof(Zygote._jvec)}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Matrix{Int64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Matrix{Int64}}, Tuple{Zygote.var\"#2763#back#609\"{Zygote.var\"#603#607\"{Matrix{Int64}, Tuple{Int64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}}}, Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}}}}}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}})(Δ::Vector{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [21] (::Zygote.var\"#75#76\"{Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Matrix{Float32}}, Tuple{Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Matrix{Float32}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, typeof(Zygote._jvec)}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(InferOptBenchmarks.Warcraft.dijkstra_maximizer)}, Tuple{Matrix{Float32}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Matrix{Int64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Matrix{Int64}}, Tuple{Zygote.var\"#2763#back#609\"{Zygote.var\"#603#607\"{Matrix{Int64}, Tuple{Int64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}}}, Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}}}}}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}})(Δ::Vector{Int64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface.jl:91\n [22] withjacobian(f::Function, args::Matrix{Float32})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/grad.jl:150\n [23] jacobian(f::Function, args::Matrix{Float32})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/grad.jl:128\n [24] top-level scope\n    @ ~/work/JuliaCon2024-InferOpt/JuliaCon2024-InferOpt/main.qmd:145"
  },
  {
    "objectID": "main.html#computing-derivatives-forwarddiff",
    "href": "main.html#computing-derivatives-forwarddiff",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Computing derivatives (ForwardDiff)",
    "text": "Computing derivatives (ForwardDiff)\n… or is zero almost everywhere\n\nusing ForwardDiff\n\ng = ForwardDiff.jacobian(maximizer, θ)\nheatmap(g; kw...)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nany(g .!= 0.0)\n\nfalse"
  },
  {
    "objectID": "main.html#regularizing-the-maximizer",
    "href": "main.html#regularizing-the-maximizer",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Regularizing the maximizer",
    "text": "Regularizing the maximizer\n\nusing InferOpt\n\nperturbed_maximizer = PerturbedMultiplicative(maximizer; ε=0.2, nb_samples=100)\nyp = perturbed_maximizer(-θ_true)\n\n12×12 Matrix{Float64}:\n 1.0   0.0   0.0   0.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.48  0.52  0.0   0.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.38  0.47  0.15  0.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.53  0.43  0.04  0.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.01  0.95  0.04  0.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.0   0.01  0.99  0.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.0   0.0   0.01  1.0  0.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.0   0.0   0.0   0.0  1.0   0.0   0.0   0.0   0.0  0.0  0.0   0.0\n 0.0   0.0   0.0   0.0  0.02  0.98  0.0   0.0   0.0  0.0  0.0   0.0\n 0.0   0.0   0.0   0.0  0.0   0.02  0.98  0.0   0.0  0.0  0.0   0.0\n 0.0   0.0   0.0   0.0  0.0   0.0   0.02  0.98  0.0  0.0  0.44  0.0\n 0.0   0.0   0.0   0.0  0.0   0.0   0.0   0.02  1.0  1.0  0.56  1.0\n\n\n\nheatmap(yp; kw..., legend=true)"
  },
  {
    "objectID": "main.html#it-is-now-differentiable",
    "href": "main.html#it-is-now-differentiable",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "It is now differentiable!",
    "text": "It is now differentiable!\nThanks to custom backward rules\n\nZygote.jacobian(perturbed_maximizer, θ)[1]\n\n144×144 Matrix{Float64}:\n  0.0        0.0        0.0         …   0.0         0.0         0.0\n -0.187746   0.511398   0.301636        0.0128768   0.108458   -0.32656\n -0.094079   0.0432884  0.140508        0.00417465  0.0693126  -0.0824386\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0         …   0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  ⋮                                 ⋱                          \n  0.0        0.0        0.0         …   0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.0        0.0        0.0         …   0.0         0.0         0.0\n  0.0        0.0        0.0             0.0         0.0         0.0\n  0.390815  -0.068813   0.00554018     -0.2066      0.732822    0.239241\n  0.0        0.0        0.0             0.0         0.0         0.0"
  },
  {
    "objectID": "main.html#allows-defining-a-differentiable-loss",
    "href": "main.html#allows-defining-a-differentiable-loss",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Allows defining a differentiable loss",
    "text": "Allows defining a differentiable loss\nFor supervised learning:\n\nloss = FenchelYoungLoss(perturbed_maximizer)\nloss(θ, y_true)\n\n2.502653261239063\n\n\nGradients are defined:\n\nheatmap(Zygote.gradient(t -&gt; loss(t, y_true), θ)[1]; kw..., legend=true)"
  },
  {
    "objectID": "main.html#training",
    "href": "main.html#training",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Training",
    "text": "Training\nUsual Flux training loop\n\nusing Flux\n\nopt_state = Flux.setup(Adam(1e-3), model)\nloss_history = Float64[]\nfor epoch in 1:50\n    val, grads = Flux.withgradient(model) do m\n        sum(loss(m(x), y) for (x, y, _) in train_dataset) / length(train_dataset)\n    end\n    Flux.update!(opt_state, model, grads[1])\n    push!(loss_history, val)\nend\nplot(loss_history)"
  },
  {
    "objectID": "main.html#prediction",
    "href": "main.html#prediction",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Prediction",
    "text": "Prediction\nPredicted costs and path\n\n(x, y_true, θ_true) = test_dataset[1]\nθ = model(x)\ny = UInt8.(maximizer(θ))\nplot_data(x, y, θ; θ_true)"
  },
  {
    "objectID": "main.html#thank-you",
    "href": "main.html#thank-you",
    "title": "InferOpt.jl: Combinatorial Optimization-enhanced Machine Learning",
    "section": "Thank you!",
    "text": "Thank you!\n\nSlides: https://batyleo.github.io/JuliaCon2024-InferOpt/\nPreprint paper for maths internals: https://arxiv.org/abs/2207.13513\nGitHub repo: https://github.com/JuliaDecisionFocusedLearning/InferOpt.jl"
  }
]